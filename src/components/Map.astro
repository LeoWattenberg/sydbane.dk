---
// Map.astro - Leaflet map component loading custom GeoJSON
import customData from "./map/customData.geo.json";

const zoom = 11; // Closer view on the highlighted line
const autoFit = true; // Fit to highlighted line if present
---

<style>
  #leaflet-map {
    height: 420px;
    width: 100%;
    border-radius: 8px;
    overflow: hidden;
  }
  
  .map-legend {
    max-width: 800px;
    margin: 2rem auto 4rem auto;
    padding: 1.5rem;
    background: #fff;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    font-size: 0.9rem;
  }
  
  .legend-title {
    font-weight: bold;
    margin-bottom: 1rem;
    color: #333;
  }
  
  .legend-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
  }
  
  .legend-section {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  
  .legend-symbol {
    display: flex;
    align-items: center;
    min-width: 30px;
  }
  
  .legend-line {
    width: 24px;
    height: 3px;
    background-color: var(--primary);
  }
  
  .legend-line.dashed {
    background: repeating-linear-gradient(
      to right,
      var(--primary) 0px,
      var(--primary) 4px,
      transparent 4px,
      transparent 8px
    );
  }
  
  .legend-station {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid var(--primary);
  }
  
  .legend-station.large {
    width: 18px;
    height: 18px;
    background-color: var(--primary);
    border-color: var(--secondary);
  }
  
  .legend-station.regular {
    background-color: var(--secondary);
  }
  
  .legend-station.small {
    width: 8px;
    height: 8px;
    background-color: var(--secondary);
  }
</style>
<section id="map">

  <div
  id="leaflet-map"
  data-zoom={zoom}
  data-autofit={autoFit}
  data-geojson={JSON.stringify(customData)}
>
</div>

<div class="map-legend">
  <div class="legend-title">Legende</div>
  <div class="legend-grid">
    <div class="legend-section">
      <strong>Strækninger</strong>
      <div class="legend-item">
        <div class="legend-symbol">
          <div class="legend-line"></div>
        </div>
        <span>Eksisterende strækninger</span>
      </div>
      <div class="legend-item">
        <div class="legend-symbol">
          <div class="legend-line dashed"></div>
        </div>
        <span>Gammle strækninger (skal genoprættes)</span>
      </div>
    </div>
    
    <div class="legend-section">
      <strong>Stationer</strong>
      <div class="legend-item">
        <div class="legend-symbol">
          <div class="legend-station large"></div>
        </div>
        <span>Eksisterende stationer</span>
      </div>
      <div class="legend-item">
        <div class="legend-symbol">
          <div class="legend-station regular"></div>
        </div>
        <span>Nye stationer hos eksisterende strækninger</span>
      </div>
      <div class="legend-item">
        <div class="legend-symbol">
          <div class="legend-station small"></div>
        </div>
        <span>Nye stationer hos restaureret strækninger</span>
      </div>
    </div>
  </div>
</div>
</section>

<!-- Load Leaflet CSS and UMD JS via CDN to avoid bare import specifier errors in the browser -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script type="module">
  // Only run client-side
  if (typeof window !== "undefined") {
    const el = document.getElementById("leaflet-map");
    if (el) {
      // Avoid initializing the same DOM node more than once
      if (!el._leafletInitialized) {
        el._leafletInitialized = true;

        // Safe dataset parsing
        let center = [0, 0];
        let zoom = 10;
        let geojson = { type: "FeatureCollection", features: [] };
        let autoFit = false;
        try {
          center = el.dataset.center ? JSON.parse(el.dataset.center) : center;
          zoom = el.dataset.zoom ? parseInt(el.dataset.zoom, 10) : zoom;
          geojson = el.dataset.geojson
            ? JSON.parse(el.dataset.geojson)
            : geojson;
          autoFit = el.dataset.autofit === "true" || el.dataset.autofit === "1";
        } catch (e) {
          // if parsing fails, fall back to defaults
          // console.warn('Map dataset parse error', e);
        }

        const TILE_URL =
          "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png";
        const TILE_OPTS = {
          attribution: "&copy; OpenStreetMap contributors &copy; CARTO",
          subdomains: "abcd",
          maxZoom: 20,
        };

        const map = window.L
          ? window.L.map(el, { scrollWheelZoom: false }).setView(center, zoom)
          : L.map(el, { scrollWheelZoom: false }).setView(center, zoom);
        L.tileLayer(TILE_URL, TILE_OPTS).addTo(map);

        const LARGE_STATIONS = new Set([
          "Flensburg",
          "Padborg",
          "Tinglev",
          "Tønder",
          "Rødekro",
          "Kliplev",
          "Gråsten",
          "Sønderborg St.",
          "Sønderborg",
        ]);

        function baseFeatureStyle(feature) {
          const p = feature && feature.properties ? feature.properties : {};
          let style;
          if (p.kind === "rail") {
            // Base rail style (secondary color but thinner)
            style = { color: "var(--primary)", weight: 3, opacity: 0.9 };
          } else {
            style = {
              color: "var(--primary)",
              weight: 2,
              opacity: 0.6,
              fillOpacity: 0.25,
            };
          }
          // If the GeoJSON explicitly marks the feature as dashed, render it more muted
          if (p["stroke-dasharray"]) {
            // Use a subtle gray and lower visual weight so dashed branches recede visually
            style.dashArray = p["stroke-dasharray"];
            // Only mute non-highlighted routes

              style.color = "var(--primary)";
              style.opacity = 0.6;
              // slightly thinner so dashes read as secondary
              style.weight = Math.max(1, (style.weight || 2) - 1);
            
          }
          return style;
        }

        function createStationMarker(feature, latlng) {
          const name = feature.properties?.name || "";
          const isLarge = LARGE_STATIONS.has(name);
          
          // Check if this station is on a dashed branch line
          const isDashedBranch = [
            "Aabenraa",
            "Sønderborg Busstation",
            "Sønderborg Ø/Retten", 
            "Augustenborg",
            "Ketting",
            "Egen",
            "Guderup /LINAK",
            "Svenstrup",
            "Gildbro / DANFOSS",
            "Havnbjerg",
            "Langesø",
            "NORDBORG"
          ].includes(name);
          
          let radius;
          if (isDashedBranch) {
            radius = 4; // Smaller for dashed branch stations
          } else {
            radius = isLarge ? 9 : 6; // Original sizing for main line stations
          }
          
          const fillColor = isLarge ? "var(--primary)" : "var(--secondary)";
          const color = isLarge ? "var(--secondary)" : "var(--primary)";
          return L.circleMarker(latlng, {
            radius,
            fillColor,
            color,
            weight: 1,
            opacity: 1,
            fillOpacity: 1,
          });
        }

        const railLineLayers = [];

        const geoLayer = L.geoJSON(geojson, {
          style: baseFeatureStyle,
          pointToLayer: (feature, latlng) => {
            if (feature.properties?.kind === "station")
              return createStationMarker(feature, latlng);
            // Non-station point (if any) – fully opaque
            return L.circleMarker(latlng, {
              radius: 4,
              fillColor,
              color,
              weight: 1,
              opacity: 1,
              fillOpacity: 1,
            });
          },
          onEachFeature: (feature, lyr) => {
            if (feature.properties?.name) {
              const desc = feature.properties.description || "";
              lyr.bindPopup(
                `<strong>${feature.properties.name}</strong><br/>${desc}`
              );
            }
            // If this layer is a station marker, enforce full opacity in case a renderer
            // or external stylesheet applied translucency after creation.
            if (
              feature.properties?.kind === "station" &&
              typeof lyr.setStyle === "function"
            ) {
              try {
                lyr.setStyle({ fillOpacity: 1, opacity: 1 });
              } catch (e) {
                // Not critical — silently continue if setStyle isn't supported.
              }
            }
          },
        }).addTo(map);

        // Fit to the highlighted rail line(s) when requested, otherwise fit to all features
        if (autoFit) {
          const target = railLineLayers.length
            ? railLineLayers
            : geoLayer.getLayers();
          if (target && target.length) {
            const group = L.featureGroup(target);
            // small padding so markers/lines don't touch the edges
            map.fitBounds(group.getBounds(), { padding: [25, 25] });
          }
        }

        // Trigger a resize in case the map container was hidden before initialization
        setTimeout(() => map.invalidateSize(), 50);
      }
    }
  }
</script>
